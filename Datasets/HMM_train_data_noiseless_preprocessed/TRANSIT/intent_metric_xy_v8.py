#! /usr/bin/env pythonimport numpy as npimport matplotlib.pyplot as pltimport matplotlib as mplimport argparseimport osimport csvimport globimport matplotlib.cbook as cbookimport intents_utils as intsimport file_utils# CHANGES# i5#   - Considers ground truth files under the 'intent_mover' naming convention# i6#   - Turns the fifth plot into 'presence data'#   - Also brought back the confusion matrix#   - Brought back all_data_analysis.csv - BROKEN# i8#   - Runs all plot generating and analysis funtions independently from the online classifier#   - Requires that the probability report HII and hmm-formatted files exist#   - Generates the following plots (customized with command line arguments)#       - basic position plot: file_utils.createBasicPositionPlot(hmmFormattedFile)#       - HII prediction plot: file_utils.createHIIPredictionPlot(probReportHIIFile)#       - color-coded position plot: file_utils.createColorCodedPositionPlot(hmmFormattedFile, probReportHIIFile)#       - animated color-coded position plot: file_utils.createAnimatedGIF(hmmFormattedFile, probReportHIIFile)version = 'i8'gtFile = ''def scientificNotation(value):    if value == 0:        return '0'    else:        e = np.log10(np.abs(value))        m = np.sign(value) * 10 ** (e - int(e))        return r'${:.0f} \cdot 10^{{{:d}}}$'.format(m, int(e))def MillisecondToSecondNotation(value):    # print value    return r'$%d$' % (value)def main():    #print("Starting Program")    fnameToSkip = []    print()    print("*"*100)    print("start")    # import data    parser = argparse.ArgumentParser(description='Process Input')    parser.add_argument('-d', '--dir', type=str, required=True,                        help='Directory Of Probability CSV files')    parser.add_argument('-v', '--verbose', action='store_true',                        help='Verbose output that shows each graph before saving')    parser.add_argument('-ip', '--HII_intent_plot', action='store_true',                        help='Generate the HII prediction plot.')    parser.add_argument('-rp', '--regular_intent_plot', action='store_true',                        help='Generate the old-version prediction plot.')    parser.add_argument('-cp', '--xy_color_plot', action='store_true',                        help='Generate the color-coded position plot.')    parser.add_argument('-p', '--xy_plot', action='store_true',                        help='Generate the regular position plot.')    parser.add_argument('-a', '--xy_anim_plot', action='store_true',                        help='Generate the color-coded animated position plot.')    args = parser.parse_args()    if not os.path.exists(args.dir):        print("error directory doesn't exist")        return -1    if os.path.isfile(args.dir):        print("Error: Expected Directory not File")        return -1    print(args.dir)    accuracy_list = []    early_predict_list = []    early_predict_list_2 = []    changes_list = []    filename_list = []    hmmFormattedFile =''    probReportHIIFile = ''    probReportFile = ''    for path, subdirs, files in os.walk(args.dir):        for name in files:            filename = os.path.join(path, name)            if '.pdf' in name or '.pkl' in name or '.json' in name:                print ("Skip: ", name)                continue            print('Filename = ', filename)            if 'hmm_formatted.csv' in name:                 hmmFormattedFile = os.path.join(path, name)                 print ("HMM formatted:", hmmFormattedFile)            if 'probability_report_HII.csv' in name:                probReportHIIFile = os.path.join(path, name)                print("Probability report HII: ", probReportHIIFile)            if 'probability_report.csv' in name:                probReportFile = os.path.join(path, name)                print("Probability report: ", probReportFile)            #if 'GT' in name or 'intent_mover' in name:            #    gtFile = os.path.join(path, name)    ##########################################################################################    ############    ############        Generate XY plot    ############    ###########################################################################################    if args.xy_plot:        file_utils.createBasicPositionPlot(hmmFormattedFile)    ##########################################################################################    ############    ############        Generate HII prediction plot    ############    ###########################################################################################    if args.HII_intent_plot:        file_utils.createHIIPredictionPlot(probReportHIIFile)    ##########################################################################################    ############    ############        Generate color-coded XY plot    ############    ###########################################################################################    if args.xy_color_plot:        file_utils.createColorCodedPositionPlot(hmmFormattedFile, probReportHIIFile)        ##########################################################################################    ############    ############        Generate animated color-coded animated XY plot    ############    ###########################################################################################    if args.xy_anim_plot:        file_utils.createAnimatedGIF(hmmFormattedFile, probReportHIIFile)    ##########################################################################################    ############    ############        File cleaned up to here, so return    ############    ###########################################################################################    return    ##########################################################################################    ############    ############        Generate HII prediction plot and accuracy    ############    ###########################################################################################    dataHII = np.genfromtxt(probReportHIIFile, delimiter=',')    filename = probReportHIIFile.replace("_probability_report_HII.csv", '_intent_graph_' + version + '.pdf')    #print('******* NEW: Output filename: ' + filename)    # Main plot    fig = plt.figure(figsize=(16, 9), dpi=72)    fig.suptitle("%s" % (filename), fontsize=14)    axs = plt.subplot2grid((4, 1), (0, 0), rowspan = 2)    #yAxisValues = np.arange(-1, 20, 1)    #Set up the plot axis values    yAxisLabels = ['', 'UNK',]    numAxisLabels = 1    for model in ints.intentsDict.values():        yAxisLabels.append(model['name'])        yAxisLabels.append('')        numAxisLabels = numAxisLabels + 2    print (numAxisLabels, yAxisLabels)    yAxisValues = np.arange(-1, numAxisLabels, 1)   # Change 16 when you change number of behaviors    #yAxisLabels = ['', 'UNK', 'RAM', '', 'BENIGN', '', 'BLOCK', '', 'HERD', '', 'CROSS', '', 'OVERTAKE', '', 'HEADON', '', 'TRANSIT']    #yAxisLabels = ['', 'UNK', 'RAM', '', 'BENIGN', '', 'BLOCK', '', 'HERD', '', 'CROSS', '', 'OVERTAKE', '', 'HEADON', '', 'STATIONARY', '', 'TRANSIT', '', 'WAIT']    axs.set_yticks(yAxisValues, yAxisLabels)    plt.subplots_adjust(wspace = 0.5, hspace=0.5)    xdata = dataHII[:,1]    ydata = dataHII[:,4]    for i in range(len(dataHII[:,4])):        plotID = ints.getModelPlotIDFromUNRIntentID(ints.intentsDict, int(ydata[i]))        ydata[i] = plotID    axs.set_xlim([0, len(xdata)])    axs.scatter(xdata, ydata)    # Behavior phase plot    axs_bp = plt.subplot2grid((4, 1), (2, 0), rowspan = 1)    axs_bp.invert_yaxis()    axs_bp.xaxis.set_visible(False)    axs_bp.set_xlim(0, len(xdata))    categoryNames = list(ints.behPhaseHIIDict.values())    categoryColors = plt.cm.RdYlGn(np.linspace(0.15, 0.85, len(ints.behPhaseHIIDict)))    stages = [0]*len(ints.behPhaseHIIDict)    bp_data = dataHII[:, 2].astype(int)  # the 2 needs to be parameterized    #print(gt_data, len(gt_data))    for phaseID in ints.behPhaseHIIDict.keys():        for i in bp_data:            if i == phaseID:                stages[i] += 1    #print(stages)    dt = np.array(list(stages)).T    #print (dt)    data_cum = dt.cumsum()    #print(data_cum)    labels = ('Phase')    for i, (colname, color) in enumerate(zip(categoryNames, categoryColors)):        #print ('i = ', i)        #print ('colname = ', colname, 'color = ', color)        widths = dt[i]        starts = data_cum[i] - widths        #print ('starts = ', starts, 'widths = ', widths)        rects = axs_bp.barh(labels, widths, left=starts, height=0.3, label=colname, color=color)        r, g, b, _ = color        text_color = 'white' if r * g * b < 0.5 else 'darkgrey'        # axs_bp.bar_label(rects, label_type='center', color=text_color, labeller=axs_bp.get_labeller())        # Removed the labeller because it doesn't support matplotlib > 3.4+        axs_bp.bar_label(rects, label_type='edge', color=text_color)                #There's an issue with using  "label_type='center'" in matplotliv version 3.7+, therefore either use "label_type='edge'" or the following                # for rect in rects:                #     width = rect.get_width()                #     height = rect.get_height()                #     x = rect.get_x()                #     y = rect.get_y()                #                #     axs_bp.annotate(                #         f'{width}',  # Label text                #         (x + width / 2, y + height / 2),  # Position of the label                #         color=text_color,                #         ha='center',  # Horizontal alignment                #         va='center'  # Vertical alignment                #     )        axs_bp.legend(ncols=len(categoryNames), bbox_to_anchor=(0, 1), loc='lower left', fontsize='small')    # # Ground truth plot    axs_gt = plt.subplot2grid((4, 1), (3, 0), rowspan = 1)    axs_gt.invert_yaxis()    axs_gt.xaxis.set_visible(False)    axs_gt.set_xlim(0, len(xdata))    gt_data = dataHII[:, 3].astype(int)  # the 3 needs to be parameterized    categoryNames = []    stages = []    behID = gt_data[0]    count = 0    for i in range(len(gt_data)):        #print(i, gt_data[i])        if behID == gt_data[i]: # seen the same behavior ID            count += 1        else:                   # new behavior ID            # Add prior behavior and number of frames to categoryNames and stages            categoryNames.append(ints.getUNRIntentNameFromUNRIntentID(ints.intentsDict, behID))            stages.append(count)            # Reset behavior ID            behID = gt_data[i]            count = 0    # Add last behavior segment    categoryNames.append(ints.getUNRIntentNameFromUNRIntentID(ints.intentsDict, behID))    stages.append(count)    categoryColors = plt.colormaps['RdYlGn'](np.linspace(0.15, 0.85, len(categoryNames)))    #print(stages)    dt = np.array(list(stages)).T    #print (dt)    data_cum = dt.cumsum()    #print(data_cum)    labels = ('Ground truth')    for i, (colname, color) in enumerate(zip(categoryNames, categoryColors)):        #print ('i = ', i)        #print ('colname = ', colname, 'color = ', color)        widths = dt[i]        starts = data_cum[i] - widths        #print ('starts = ', starts, 'widths = ', widths)        rects = axs_gt.barh(labels, widths, left=starts, height=0.3, label=colname, color=color)        r, g, b, _ = color        text_color = 'white' if r * g * b < 0.5 else 'darkgrey'        axs_gt.bar_label(rects, label_type='center', color=text_color)        axs_gt.legend(ncols=len(categoryNames), bbox_to_anchor=(0, 1), loc='lower left', fontsize='small')    print ('Saving intent graph:     ', filename)    try:        plt.savefig(filename)    except Exception as e:        print("Error saving intent graph: ", filename)        print("The error occurred was: " + str(e))    finally:        fig.clear()    # # Compute accuracy HII    # beh_phase = dataHII[:,2]    # ground_truth = dataHII[:,3]    # predicted_label = dataHII[:,4]    # num_correct = 0    # num_predict = 0    # intentName = ints.getIntentNameFromString(probReportHIIFile, ints.intentsDict)    # intentIDUNR = ints.getIDUNRFromName(intentName, ints.intentsDict)    # #print("Intent name: ", intentName, "intent ID: ", intentIDUNR)    # idx = 0    # for phase in beh_phase:    #     if phase == 3 and idx > 20:  # Execute phase    #         if ground_truth[idx] == intentIDUNR:    #             # Increment the number of valid frames    #             num_predict = num_predict + 1    #             # Increment num_correct if the predicted label matches the ground truth    #             if intentIDUNR == 15:    #                 if predicted_label[idx] == 3:    #                     num_correct = num_correct + 1    #             elif ground_truth[idx] == predicted_label[idx]:    #                 num_correct = num_correct + 1    #     idx = idx + 1    # # print("No transit or benign", num_correct, num_predict)    # try:    #     accuracy = float(num_correct) / float(num_predict)    # except:    #     accuracy = 0    # accuracy_list.append(accuracy)    # print("accuracy", accuracy)    # # print("accuracy_list", accuracy_list)    # # 07/27/23 Ayesh    #    # #get the count of transit frames    # idx = 0    # transit_count = 0    # for phase in beh_phase:    #     if phase == 2 and idx > 20:    #         transit_count += 1    #    #     idx = idx + 1    # # print("transit_count", transit_count)    #    # # get the count of benign frames    # idx = 0    # benign_count = 0    # for phase in beh_phase:    #     if phase == 3 and idx > 20:    #         if ground_truth[idx] == 3:    #             benign_count += 1    #     idx = idx + 1    # # print("benign_count", benign_count)    #    # # Get accuracy of only transit    # accuracy_with_transit_list = []    # num_correct_transit = 0    # num_predict_transit = 0    # # print("Intent name: ", intentName, "intent ID: ", intentIDUNR)    # idx = 0    # for phase in beh_phase:    #     if (phase == 2) and idx > 20:  # Execute phase    #         if ground_truth[idx] == intentIDUNR:    #             # Increment the number of valid frames    #             num_predict_transit = num_predict_transit + 1    #             # Increment num_correct if the predicted label matches the ground truth    #             if ground_truth[idx] == predicted_label[idx]:    #                 num_correct_transit = num_correct_transit + 1    #     idx = idx + 1    # # print("With transit", num_correct_transit, num_predict_transit)    # try:    #     accuracy_with_transit = float(num_correct_transit) / float(num_predict_transit)    # except:    #     accuracy_with_transit = 0    # accuracy_with_transit_list.append(accuracy_with_transit)    # print("transit acc", accuracy_with_transit_list)    #    # # Get accuracy of only benign    # accuracy_with_benign_list = []    # num_correct_benign = 0    # num_predict_benign = 0    # # print("Intent name: ", intentName, "intent ID: ", intentIDUNR)    # idx = 0    # for phase in beh_phase:    #     if phase == 3 and idx > 20:  # Execute phase    #         if ground_truth[idx] == 3:    #             # Increment the number of valid frames    #             num_predict_benign = num_predict_benign + 1    #             # Increment num_correct if the predicted label matches the ground truth    #             if ground_truth[idx] == predicted_label[idx]:    #                 num_correct_benign = num_correct_benign + 1    #     idx = idx + 1    # # print("With benign", num_correct_benign, num_predict_benign)    # try:    #     accuracy_with_benign = float(num_correct_benign) / float(num_predict_benign)    # except:    #     accuracy_with_benign = 0    # accuracy_with_benign_list.append(accuracy_with_benign)    # print("benign acc", accuracy_with_benign_list)    # ########################### Early Detection Prediction ##############################    # # 08/11/23 Ayesh    #    # # Early detection behavior    # # No. of frames from the 1st frame until the first prediction of the correct behavior    # id = 0    # early_detection_behavior = 0    # for phase in beh_phase:    #     if phase == 3 and id > 20:  # Execute phase    #         if ground_truth[id] == intentIDUNR:    #             if ground_truth[id] == predicted_label[id]:    #                 early_detection_behavior = id    #                 break    #     id = id + 1    #    # # to get the difference between early_detection_behavior frame and the first frame    # early_detection_behavior -= 1    #    # print("early_detection_behavior", early_detection_behavior)    #    # # Early detection hostile    # # No. of frames from the 1st frame until the first prediction of a hostile behavior (ram = 1, block = 5, herd = 7)    # id = 0    # early_detection_hostile = 0    # for phase in beh_phase:    #     if phase == 3 and id > 20:  # Execute phase    #         if ground_truth[id] == intentIDUNR:    #             if predicted_label[id] == 1 or predicted_label[id] == 5 or predicted_label[id] == 7:    #                 early_detection_hostile = id    #                 break    #     id = id + 1    #    # # to get the difference between early_detection_behavior frame and the first frame    # early_detection_hostile -= 1    #    # print("early_detection_hostile", early_detection_hostile)    #    # #Get accuracy including both transit and benign    # accuracy_with_transit_and_benign_list = []    # num_correct = 0    # num_predict = 0    # # print("Intent name: ", intentName, "intent ID: ", intentIDUNR)    # idx = 0    # for phase in beh_phase:    #     if (phase == 2 or phase == 3) and idx > 20:  # Execute phase    #         # Increment the number of valid frames    #         num_predict = num_predict + 1    #         # Increment num_correct if the predicted label matches the ground truth    #         if ground_truth[idx] == predicted_label[idx]:    #             num_correct = num_correct + 1    #     idx = idx + 1    # print("With transit and benign", num_correct, num_predict)    # try:    #     accuracy_with_transit_and_benign = float(num_correct) / float(num_predict)    # except:    #     accuracy_with_transit_and_benign = 0    # accuracy_with_transit_and_benign_list.append(accuracy_with_transit_and_benign)    #    # # Get accuracy including transit but no benign    # accuracy_with_transit_list = []    # num_correct = 0    # num_predict = 0    # # print("Intent name: ", intentName, "intent ID: ", intentIDUNR)    # idx = 0    # for phase in beh_phase:    #     if (phase == 2 or phase == 3) and idx > 20:  # Execute phase    #         if ground_truth[idx] == intentIDUNR:    #             # Increment the number of valid frames    #             num_predict = num_predict + 1    #             # Increment num_correct if the predicted label matches the ground truth    #             if ground_truth[idx] == predicted_label[idx]:    #                 num_correct = num_correct + 1    #     idx = idx + 1    # print("With transit", num_correct, num_predict)    # try:    #     accuracy_with_transit = float(num_correct) / float(num_predict)    # except:    #     accuracy_with_transit = 0    # accuracy_with_transit_list.append(accuracy_with_transit)    #    # # Get accuracy including benign but no transit    # accuracy_with_benign_list = []    # num_correct = 0    # num_predict = 0    # # print("Intent name: ", intentName, "intent ID: ", intentIDUNR)    # idx = 0    # for phase in beh_phase:    #     if phase == 3 and idx > 20:  # Execute phase    #         # Increment the number of valid frames    #         num_predict = num_predict + 1    #         # Increment num_correct if the predicted label matches the ground truth    #         if ground_truth[idx] == predicted_label[idx]:    #             num_correct = num_correct + 1    #     idx = idx + 1    # print("With benign", num_correct, num_predict)    # try:    #     accuracy_with_benign = float(num_correct) / float(num_predict)    # except:    #     accuracy_with_benign = 0    # accuracy_with_benign_list.append(accuracy_with_benign)    ##########################################################################################    ############    ############        Generate prediction line graph    ############    ###########################################################################################    each = probReportFile    # Find local intent in file path    if 'RAM' in each or 'ram' in each:        intent = 'RAM'    elif 'BLOCK' in each or 'block' in each:        intent = 'BLOCK'    elif 'HERD' in each or 'herd' in each:        intent = 'HERD'    elif 'BENIGN' in each or 'benign' in each:        intent = 'BENIGN'    elif 'CROSS' in each or 'cross' in each:        intent = 'CROSS'    elif 'OVERTAKE' in each or 'overtake' in each:        intent = 'OVERTAKE'    elif 'HEADON' in each or 'headon' in each:        intent = 'HEADON'    # elif 'STATIONARY' in each or 'stationary' in each:    #     intent = 'STATIONARY'    elif 'TRANSIT' in each or 'transit' in each:        intent = 'TRANSIT'    # elif 'WAIT' in each or 'wait' in each:    #     intent = 'WAIT'    else:        print("ERROR: NO PRIMARY BEHAVIOR IN FILENAME")    #print('File for probability_report: ' + each)    filename_list.append(each)    debug_cnt = 0    #print("Processing: %s" % (each))    filename = each.replace("_probability_report.csv", '_' + version)    print('Output filename: ' + filename)    # graph predictions    data = np.genfromtxt(each, delimiter=',')[1:]    # data[:,0] = range(len(data[:,0]))    block_data = data[data[:, 6] == 5]    ram_data = data[data[:, 6] == 1]    herd_data = data[data[:, 6] == 7]    benign_data = data[data[:, 6] == 3]    cross_data = data[data[:, 6] == 9]    overtake_data = data[data[:, 6] == 11]    headon_data = data[data[:, 6] == 13]    # stationary_data = data[data[:, 6] == 15]    transit_data = data[data[:, 6] == 17]    # wait_data = data[data[:, 6] == 19]    missing_data = data[data[:, 6] == 8]    unknown_data = data[data[:, 6] == 0]    behaviors = [block_data, ram_data, herd_data, benign_data, overtake_data, headon_data,                 cross_data, transit_data]        # behaviors = [block_data, ram_data, herd_data, benign_data, overtake_data, headon_data,    #                 stationary_data, cross_data, transit_data, wait_data]    #print(min(block_data[:, 7]),max(block_data[:, 7]), ram_data, herd_data, len(benign_data), len(cross_data), len(overtake_data),    #      len(headon_data), len(stationary_data), , len(transit_data), len(wait_data), len (data) )    # biggest_len = max(len(block_data), len(ram_data), len(herd_data), len(benign_data), len(cross_data),    #                     len(overtake_data), len(headon_data), len(stationary_data), len(missing_data),    #                     len(transit_data), len(wait_data), len(unknown_data) )        biggest_len = max(len(block_data), len(ram_data), len(herd_data), len(benign_data), len(cross_data),                      len(overtake_data), len(headon_data), len(missing_data),                      len(transit_data), len(unknown_data))    # print(block_data)    # Add presence data    #   21/06/2018 - Dalton    presence_d = data[data[:, 6] == 8]    # print(block_data == presence_d)    # Create gt data list    #   Use 0 for GIP, 1 for ACTIVE, .5 for other    gt_data = [1 for i in range(0, len(data))]    """    with open( gtFile ) as ground_truth:        gt_data = []        for line in ground_truth:            if 'GIP' in str( line ):                gt_data.append( 0.0 )            elif intent + '_' + intent in str( line ):                gt_data.append( 1.0 )            else:                gt_data.append( 0.5 )    """    # plot a 4 sublpot graph with one combined graph and 3 of the    #   individual probabilities to understand meaning easier    fig = plt.figure(1, figsize=(14, 44), dpi=72)    fig.suptitle("%s" % (filename), fontsize=22)    formatter = mpl.ticker.FuncFormatter(        lambda x, p: MillisecondToSecondNotation(x))    fig.text(0.5, 0.03, 'Time Step', ha='center', va='center',                fontsize=14, fontweight='bold')    fig.text(0.03, 0.5, 'Probability', ha='center', va='center',                rotation='vertical', fontsize=14, fontweight='bold')    plt.subplots_adjust(hspace=.2, left=.06, top=.90, right=0.97,                        bottom=0.07)    # BLOCK    g1 = plt.subplot(13,1,1)    block_data[:, 0] = range(len(block_data[:, 0]))    plt.plot(block_data[:, 0], block_data[:, 7], color='blue',                linewidth=2.0)    plt.title('Block Prediction')    #plt.ylim([min(block_data[:, 7]) + 0.01, max(block_data[:, 7]) + 0.01])    plt.xlim(left=0)    plt.setp(g1.get_xticklabels(), visible=False)    plt.gca().xaxis.set_major_formatter(formatter)    # BENIGN    g2 = plt.subplot(13,1,2)    benign_data[:, 0] = range(len(benign_data[:, 0]))    plt.plot(benign_data[:, 0], benign_data[:, 7], color='brown',                linewidth=2.0)    plt.title('Benign Prediction')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g2.get_xticklabels(), visible=False)    plt.gca().xaxis.set_major_formatter(formatter)    # RAM    g3 = plt.subplot(13,1,3)    ram_data[:, 0] = range(len(ram_data[:, 0]))    plt.plot(ram_data[:, 0], ram_data[:, 7], color='red',                linewidth=2.0)    plt.title('Ram Prediction')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g3.get_xticklabels(), visible=False)    plt.gca().xaxis.set_major_formatter(formatter)    # HERD    g4 = plt.subplot(13,1,4)    herd_data[:, 0] = range(len(herd_data[:, 0]))    plt.plot(herd_data[:, 0], herd_data[:, 7], color='greenyellow',                linewidth=2.0)    plt.title('Herd Prediction')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g4.get_xticklabels(), visible=False)    plt.gca().xaxis.set_major_formatter(formatter)    # CROSS    g5 = plt.subplot(13,1,5)    presence_d[:, 0] = range(len(presence_d[:, 0]))    plt.plot(cross_data[:, 0], cross_data[:, 7], color='cyan',                linewidth=2.0)    plt.title('Cross Presence')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g5.get_xticklabels(), visible=True)    plt.gca().xaxis.set_major_formatter(formatter)    # OVERTAKE    g6 = plt.subplot(13,1,6)    presence_d[:, 0] = range(len(presence_d[:, 0]))    plt.plot(overtake_data[:, 0], overtake_data[:, 7], color='pink',                linewidth=2.0)    plt.title('Overtake Presence')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g6.get_xticklabels(), visible=True)    plt.gca().xaxis.set_major_formatter(formatter)    # HEADON    g7 = plt.subplot(13,1,7)    presence_d[:, 0] = range(len(presence_d[:, 0]))    plt.plot(headon_data[:, 0], headon_data[:, 7], color='olive',                linewidth=2.0)    plt.title('Headon Presence')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g7.get_xticklabels(), visible=True)    plt.gca().xaxis.set_major_formatter(formatter)    # # STATIONARY    # g8 = plt.subplot(13,1,8)    # presence_d[:, 0] = range(len(presence_d[:, 0]))    # plt.plot(stationary_data[:, 0], stationary_data[:, 7], color='orange',    #             linewidth=2.0)    # plt.title('Stationary Presence')    # plt.ylim([-1.01, 1.01])    # plt.xlim(left=0)    # plt.setp(g8.get_xticklabels(), visible=True)    # plt.gca().xaxis.set_major_formatter(formatter)    # TRANSIT    g8 = plt.subplot(13, 1, 9)    presence_d[:, 0] = range(len(presence_d[:, 0]))    plt.plot(transit_data[:, 0], transit_data[:, 7], color='orange',                linewidth=2.0)    plt.title('Transit Presence')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g8.get_xticklabels(), visible=True)    plt.gca().xaxis.set_major_formatter(formatter)    # WAIT    # g10 = plt.subplot(13, 1, 10)    # presence_d[:, 0] = range(len(presence_d[:, 0]))    # plt.plot(wait_data[:, 0], wait_data[:, 7], color='orange',    #             linewidth=2.0)    # plt.title('Wait Presence')    # plt.ylim([-1.01, 1.01])    # plt.xlim(left=0)    # plt.setp(g10.get_xticklabels(), visible=True)    # plt.gca().xaxis.set_major_formatter(formatter)    # MISSING    g9 = plt.subplot(13,1,11)    presence_d[:, 0] = range(len(presence_d[:, 0]))    plt.plot(missing_data[:, 0], missing_data[:, 7], color='brown',                linewidth=2.0)    plt.title('Missing Presence')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g9.get_xticklabels(), visible=True)    plt.gca().xaxis.set_major_formatter(formatter)    # UNKNOWN    g10 = plt.subplot(13,1,12)    presence_d[:, 0] = range(len(presence_d[:, 0]))    plt.plot(unknown_data[:, 0], unknown_data[:, 7], color='brown',                linewidth=2.0)    plt.title('Unknown Presence')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g10.get_xticklabels(), visible=True)    plt.gca().xaxis.set_major_formatter(formatter)    # GROUND TRUTH    g11 = plt.subplot(13,1,13)    # plt.plot(gt_data, color='purple', linewidth=2.0)    # plt.title('GT State')    # ... or MOVER Presence    #   21/06/2018 - Dalton    presence_d[:, 0] = range(len(presence_d[:, 0]))    plt.plot(presence_d[:, 0],                list(map(lambda x: (x + 1) % 2, presence_d[:, 7])),                color='purple', linewidth=2.0)    plt.title('Mover Presence')    plt.ylim([-1.01, 1.01])    plt.xlim(left=0)    plt.setp(g11.get_xticklabels(), visible=True)    plt.gca().xaxis.set_major_formatter(formatter)    # plt.tight_layout()    plt.savefig(filename + '.pdf')    if args.verbose:        plt.show()    fig.clear()    # Generate Timeline predictions # Determine Correct prediction    if 'block' in each.lower():        # print "Block Type"        class_type = 5    elif 'ram' in each.lower():        # print "Ram Type"        class_type = 1    elif 'herd' in each.lower():        # print "Herd Type"        class_type = 7    elif 'benign' in each.lower():        class_type = 3    elif 'cross' in each.lower():        class_type = 9    elif 'overtake' in each.lower():        class_type = 11    elif 'headon' in each.lower():        class_type = 13    # elif 'stationary' in each.lower():    #     class_type = 15    elif 'transit' in each.lower():        class_type = 17    # elif 'wait' in each.lower():    #     class_type = 19    else:        print("Error: Type not detected")    prediction = []    for i in range(biggest_len-1):        m = 0        for bv in behaviors:            if len(bv) > i and len(bv)> 0 :                if bv[i, 7] > m:                    m = bv[i, 7]        if m != 0:            if m == block_data[i, 7]:                prediction.append(block_data[i])            elif m == ram_data[i, 7]:                prediction.append(ram_data[i])            elif m == herd_data[i, 7]:                prediction.append(herd_data[i])            elif m == benign_data[i, 7]:                prediction.append(benign_data[i])            elif m == cross_data[i, 7]:                prediction.append(cross_data[i])            elif m == overtake_data[i, 7]:                prediction.append(overtake_data[i])            elif m == headon_data[i, 7]:                prediction.append(headon_data[i])            # elif m == stationary_data[i, 7]:            #     prediction.append(stationary_data[i])            elif m == transit_data[i, 7]:                prediction.append(transit_data[i])            # elif m == wait_data[i, 7]:            #     prediction.append(wait_data[i])    prediction = np.array(prediction)            # # Compute Accuracy            # block_num = len([prediction[i] for i in \            #                  range(len(prediction)) if prediction[i, 4] == 5])            # ram_num = len([prediction[i] for i in \            #                range(len(prediction)) if prediction[i, 4] == 1])            # herd_num = len([prediction[i] for i in \            #                 range(len(prediction)) if prediction[i, 4] == 7])            # corss_num = len([prediction[i] for i in \            #                  range(len(prediction)) if prediction[i, 4] == 9])            # overtake_num = len([prediction[i] for i in \            #                     range(len(prediction)) if prediction[i, 4] == 11])            # headon_num = len([prediction[i] for i in \            #                   range(len(prediction)) if prediction[i, 4] == 13])            # stationary_num = len([prediction[i] for i in \            #                       range(len(prediction)) if prediction[i, 4] == 15])            # transit_num = len([prediction[i] for i in \            #                       range(len(prediction)) if prediction[i, 4] == 17])            # wait_num = len([prediction[i] for i in \            #                       range(len(prediction)) if prediction[i, 4] == 19])            # num_correct = len([prediction[i] for i in \            #                    range(len(prediction)) if prediction[i, 6] == class_type])            # num_predict = len(prediction)            #try:            #    accuracy = float(num_correct) / float(num_predict)            #except:            #    accuracy = 0            #accuracy_list.append(accuracy)    ##########################################################################################    ############    ############        Generate confusion matrix    ############    ###########################################################################################    ground_truth = [class_type for i in range(len(prediction))]    # class_types = [1, 5, 7, 3, 9, 11, 13, 15, 17,  19]    class_types = [1, 5, 7, 3, 9, 11, 13, 15, 17]    confusion_mat = np.zeros([len(class_types), len(class_types)])    for i, correct_index in enumerate(class_types):        for j, predicted_index in enumerate(class_types):            for k in range(len(prediction)):                if prediction[k, 6] == predicted_index and \                        ground_truth[k] == correct_index:                    confusion_mat[i, j] += 1.0    for i, row in enumerate(confusion_mat):        if sum(row) != 0:            confusion_mat[i] = row / sum(row)    fig_conf = plt.figure(2)    ax = fig_conf.add_subplot(111)    ax.set_aspect(1)    rows = len(confusion_mat)    cols = len(confusion_mat[0])    res = ax.imshow(confusion_mat, cmap=plt.cm.viridis,                    interpolation='nearest')    for x in range(cols):        for y in range(rows):            ax.annotate(str('{0:.2f}'.format(confusion_mat[y, x])), xy=(x, y), horizontalalignment='center',                        verticalalignment='center')    cb = fig_conf.colorbar(res)    #class_list = ['RAM', 'BLOCK', 'HERD', 'BENIGN', 'CROSS', 'OVERTAKE', 'HEADON', 'STATIONARY', 'TRANSIT', 'WAIT'] # order is wrong here!!!!    #class_list = ['RAM', 'BLOCK', 'HERD', 'BENIGN', 'CROSS', 'HEADON', 'OVERTAKE', 'STATIONARY', 'TRANSIT', 'WAIT']    class_list = ['RAM', 'BLOCK', 'HERD', 'BENIGN', 'CROSS', 'HEADON', 'OVERTAKE', 'TRANSIT']    plt.xticks(range(len(class_list)), class_list, rotation='vertical')    plt.yticks(range(len(class_list)), class_list)    plt.ylabel('True label')    plt.xlabel('Predicted label')    plt.title('%s Confusion Matrix' % (filename))    confusionFile = filename + '_confusion.pdf'    print ('Saving confusion matrix: ', confusionFile)    plt.savefig(confusionFile)    if args.verbose:        plt.show()    fig_conf.clear()    ##########################################################################################    ############    ############        Compute Early Detection Rate    ############    ###########################################################################################    # print("num_predict", num_predict)    # print("early")    # early_predict = 1    # for i in reversed(range(len(prediction))):    #     # print("i", i)    #     # print("i + 1", i+1)    #     if prediction[i, 6] == class_type:    #         # print("pred", prediction[i, 6] )    #         # print("class", class_type)    #         early_predict = float((i + 1)) / float(num_predict)    #         # print("early_predict", early_predict)    #         break    # early_predict_list.append(early_predict)    # debug_cnt += 1    # # Compute Second early detection Rate    # early_predict_2 = 1    # for i in range(len(prediction)):    #     if prediction[i, 6] == class_type:    #         early_predict_2 = float(i) / float(num_predict)    #         break    # early_predict_list_2.append(early_predict_2)    # compute Persistance of Recognized intent    changes = -1    previous_state = -1    for row in prediction:        if previous_state != row[6]:            changes += 1        previous_state = row[6]    changes_list.append(changes)    # #check early_predict rate    # early_predict_rate = early_predict/ num_predict    # print("early_predict", early_predict)    # print("num_predict", num_predict)    # print("early_predict_rate", early_predict_rate)    #Save to the csv file    # filename = probReportHIIFile.replace("_probability_report_HII.csv", '_analysis_' + version + '.csv')    # print ('Saving metrics analysis: ', filename)    # with open(filename, 'w') as openfile:    #     openfile.write('Accuracy, Early Detection(behavior), Early Detection(hostile), \    #             Persistence, # Transit Frames, Accuracy of Transit, # Benign Frames, Accuracy of Benign \n')    #     openfile.write('%f, %f, %f, %f, %f, %f, %f, %f\n' % (accuracy, early_detection_behavior,    #                                             early_detection_hostile, changes, transit_count, accuracy_with_transit, benign_count, accuracy_with_benign))    ##########################################################################################    ############    ############        ALL DATA ANALYSIS    ############    ###########################################################################################    # accuracy_array = np.array(accuracy_list)    # acc_mean = np.mean(accuracy_array)    # acc_std = np.std(accuracy_array)    # # Compute Early Detection mean/std    # early_predict_array = np.array(early_predict_list)    # early_mean = np.mean(early_predict_array)    # early_std = np.std(early_predict_array)    # # Compute Early first detection    # early_predict_array_2 = np.array(early_predict_list_2)    # early_mean_2 = np.mean(early_predict_array_2)    # early_std_2 = np.std(early_predict_array_2)    # # Compute Persistence mean/std    # changes_array = np.array(changes_list)    # change_mean = np.mean(changes_array)    # change_std = np.std(changes_array)    # with open('all_data_analysis.csv', 'w') as openfile:    #     openfile.write('Type, Mean, Standard Deviation\n')    #     openfile.write('Accuracy, %f, %f\n' % (acc_mean, acc_std))    #     openfile.write('Early Detection, %f, %f\n' % (early_mean, early_std))    #     openfile.write('First Detection, %f, %f\n' % (early_mean_2, early_std_2))    #     openfile.write('Persistence, %f, %f\n' % (change_mean, change_std))    #     openfile.write('\n')    #     openfile.write('LOG, Accuracy, Early Detection, First Detection, \    #             Persistence, # Transit Frames, Accuracy With Transit, # Benign Frames, Accuracy with Benign \n')    #     count = 0    #     for each in filename_list:    #         openfile.write('%s, %f, %f, %f, %f, %f, %f, %f, %f\n' % \    #                        (each, accuracy_list[count], early_predict_list[count],    #                         early_predict_list_2[count], changes_list[count],    #                         transit_count, accuracy_with_transit_list[count],    #                         benign_count, accuracy_with_benign_list[count] ))    #         count += 1if __name__ == '__main__':    main()